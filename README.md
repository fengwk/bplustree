# B+树

该库提供一个允许插入重复关键码的B+树实现，该实现方案参考了[一种处理B+树重复键值的方法](https://www.ixueshu.com/document/1ea00ff27973989b76d7c4d383484657318947a18e7f9386.html)，文献中描述了一种除溢出页之外的处理重复关键码方法，由于该文献并未详述实现细节，因此在具体实现上细节上会有一定差异，本文档将给出该版本实现中的B+树定义与具体的实现细节阐述。

如果此前从未了解过B+树，建议优先学习[B+树wiki](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91)，通常B+树的实现中约定不引入重复关键码，或者使用溢出页处理重复关键码，当前实现并非采用前两种方案实现，因此在定义上会与wiki中有一定差异。

当前库主要用于了解与学习B+树，若需实际使用当前版本实现请自行完成各项指标的测试工作。

出于可移植性考虑，B+树的核心实现中尽少使用面向对象，尽量使用方法封装。

# 定义

D.以下定义针对于m阶B+树：

1. 内部节包含分支和关键码，最多有`m`个分支和`m-1`个关键码，除根节点外最少有`ceil(m/2)`个分支和`ceil(m/2)-1`个关键码。
2. 叶子节包含关键码和对应值，点最多有`m-1`个关键码，除根节点外最少有`ceil(m/2)-1`个关键码。
3. 根节点最少有`2`个分支和`1`个关键码。
4. 内部节点中第`k`个关键码定存放的是其第`k+1`个子节点为根的子树中第一次出现的”新“的数据关键码。

DS.定义的实现细节：

1. 为了简化定义4的实现，为所有内部节点设置一个哨兵关键码，但进行具体关键码数量计算时并不计入哨兵关键码。

# 约定

1. 为了实现空关键码的定义，实现中不允许用户插入空的关键码。
2. 为了明确返回value的语义，实现中不允许用户插入空的value。

# 数据结构

内部节点（InternalNode）：

1. parent：指向父节点。
2. keys：关键码列表，按照升序列排列，首个关键码是哨兵关键码，因此数量上与分支相同，根据DS.1除根节点外最多包含`m`个，最少包含`ceil(m/2)`个。
3. children：子节点列表，`children[i]`是`keys[i]`的右子树，即D4中描述的`k`和`k+1`关系。

叶子节点（LeafNode）：

1. parent：指向父节点。
2. prev：指向前一个叶子节点。
3. next：指向后一个叶子节点。
4. keys：关键码列表，按照升序列排列，除根节点外最多包含`m-1`个，最少包含`ceil(m/2)-1`个。
5. values：值列表，`keys[i]`与`value[i]`对应。

B+树：

1. m：阶次。
2. root：根节点。

# 算法

## A.辅助算法

### 1.判断根节点

1. parent指针为空：是根节点。
2. parent指针非空：不是根节点。

### 2.判断上溢

1. 内部节点（对内部节点而言keys数量即为分支数）：keys数量大于`m`。
2. 叶子节点：keys数量大于`m-1`。

### 3.判断下溢

1. 内部节点且为根：keys数量小于2。
2. 内部节点且非根：keys数量小于`ceil(m/2)`。
3. 叶子节点且为根：keys数量小于1。
4. 叶子节点且非根：keys数量小于`ceil(m/2)-1`。

### 4.key所在子树

对于内部节点而言需要通过输入key与索引值的比较定位key所在子树。

从索引0处开始查找，直到找到首个等于key或者最后一个小于key的索引位置r，children[r]即为key所在子树。

从索引0处开始查找的隐含意义是如果keys[0]就大于key，那么就向children[0]深入，因为这是全树的最左侧。

### 5.key所在叶子

对于可能存在重复关键码的B+树而言，首次定位到叶子节点并不意味着结束。

1. key小于等于当前叶子节点末尾关键码查找结束，否则执行步骤2。
2. 通过next跳转到下一叶子节点重复步骤1。

### 6.搜索叶子节点

1. 执行A4获得首个叶子节点。
2. 执行A5获得目标叶子节点。

通过改算法找到的叶子节点是可能包含该key最靠左的节点。

### 7.在keys中查找key

查找keys中查找小于key秩最大的元素的下标。

### 8.内部节点索引更新

该算法作用于内部节点，是为了更新输入内部节点所对应父节点中的关键码值而设计的。

该算法性质来自于《一种处理B+树重复键值的方法》，内部节点第`k`个索引键值等于对应子内部节点从小到大第一个非空索引键值，如果所有都是空键值则第`k`个索引键值也是空。

1. 当前节点为根则算法结束。
2. 通过性质决定是否更新。

### 9.叶子节点索引更新

尽管通过细致的判断能够更为迅速地更新叶子节点所对应父节点位置的关键码，但出于简单性考虑这里将给出一个简明而通用的算法，这样一来会损失部分性能，但可以保持KISS原则。该算法同样依赖于性质，内部节点第`k`个索引键值等于对应子内部节点从小到大第一个非空索引键值，如果所有都是空键值则第`k`个索引键值也是空。

叶子节点前一叶子节点的最后一个关键码称作`prevLastKey`，当前叶子节点首个关键码称作`firstKey`，当前关键码对应父节点位置的关键码称作`keyInParent`。

1. 如果当前节点为空，更新`keyInParent`为空，算法结束，否则进入步骤2。
2. `prevLastKey == firstKey`，搜索首个不等于`firstKey`的关键码`foundKey`，更新`keyInParent`为`foundKey`，算法结束。
3. `prevLastKey < firstKey`，更新`keyInParent`为`firstKey`，算法结束。

### 10.解决上溢

大体类似常规B+树上溢解决思路，注意索引的更新即可。

### 11.解决下溢

大体类似常规B+树下溢解决思路，注意索引的更新即可。

## M.主算法

### 1.搜索

1. 执行A6获得key可能存在的叶子节点。
2. 执行A7获取下标`r`。
3. 查看`r+1`位置（可能越界）是否为目标key，是则返回对应value，否则查找失败。

一旦通过当前算法找到目标节点，若key也存在，就能保证其查找到的key是相同值里最靠左的。

### 2.插入

1. 若B+树为空，新建节点赋值给`root`，插入结束，否则进入步骤2。
2. 执行A6与A7定位插入点。
3. 执行插入。
4. 插入后可能引起当前叶子节点的`keyInParent`违反性质，尝试检查并更新。
5. 执行A10尝试解决上溢。

### 3.删除

1. 若B+树为空，返回空算法结束，否则进入步骤2。
2. 执行A6与A7定位要删除点，若要删除键值不存在，返回空算法结束，否则进入步骤3。
3. 执行删除。
4. 删除操作可能引起当前叶子`keyInParent`和后一个叶子节点的`nextKeyInParent`违反性质，尝试检查并更新。
5. 执行A11尝试解决下溢。